# Контролно по СДП на 2023-11-19 от 09:30

## Увод

В тази задача ще преобразуваме изрази от инфиксен запис до RPN нотация.

В изразите може да участват операциите събиране (`+`), изваждане (`-`), умножение (`*`), деление (`/`), степенуване (`^`).
Приоритетите им са стандартните, познати ви от курсовете по математика.

Ако изразът е инфиксен, допълнително ще се уточнява каква е асоциативността на операциите в него -- дали всички са с лява или са с дясна асоциативност.

За улеснение ще считаме, че валидни изрази са такива, в които (1) всички числа имат само по една цифра и (2) НЕ СЕ съдържат празни символи (whitespace).

## Уточнения

В решението на задачата можете да използвате наготово `std::stack` и `std::string` от STL. За улеснение съответните header файлове са включени в `solution.cpp`.

В шаблона за решението са включени и помощни функции, които можете да използвате наготово. Можете да ги намерите в `solution.h`:

* `isDigit` -- Проверява дали даден символ е цифра.
* `isOperation` -- Проверява дали даден символ е операция.
* `priority` -- Връща приоритета на дадена операция.

## Реализирайте фунциите

### А) Проверка за коректност

```cpp
bool verify(const std::string& expression)
```

Проверява дали подаденият ѝ инфиксен израз е коректен.

За определеност считаме, че празният низ е коректен израз.

Ако изразът съдържа празни (whitespace) символи, той НЕ Е коректен.

Например, следните инфиксни изрази са коректни:

```cpp
"1"
"1+2"
"1+2/3*4^5"
```

докато следните не са:

```cpp
"11"
"+"
"1++1"
"1+1+"
"a+2"
" 1 + 2 "
"1=2"
```

### Б) Преобразуване до RPN

```cpp
std::string toRpn(std::string expression, Associativity associativity) 
```

Получава инфиксен израз `expression` и го преобразува до неговото RPN представяне.

`associativity` указва каква е асоциативността на операциите, които участват в израза. Тя е от следния тип:

```cpp
enum class Associativity { Left, Right };
```

Ако на функцията бъде подаден празният низ (`""`), тя също трябва да връща празния низ.

Ако на функцията бъде подаден некоректен израз, да се хвърли изключение от тип `std::invalid_argument`.

*Упътване:* Използвайте стек, в който да натрупвате операции (`O`) и символен низ, в който да натрупвате резултата (`R`). Ако срещнете число, то се долепва към `R`. Ако срещнете операция сравнете приоритета ѝ с тази на върха на стека. В зависимост от резултата от проверката вадете операции и ги долепвайте към `R`.

## Дефиниция за RPN

Ще използваме следните обозначения:

* `<op>` – операция
* `<N>`, `<N1>`, `<N2>` – числа
* `<expr1>`, `<expr2>` – изрази
* `<rpn1>`, `<rpn2>` – RPN представянията на горните изрази

Представяне на инфиксен израз като RPN дефинираме индуктивно по следния начин:

|№  | Ако изразът е от вида: | то представянето му е: |
|---|------------------------|------------------------|
|1. | `<N>`                  | `<N>`                  |
|2. | `<N1><op><N2>`         | `<N1><N2><op>`         |
|3. | `<expr1><op><expr2>`   | `<rpn1><rpn2><op>`     | 

Точка 3 се прилага само тогава, когато приоритетът на операциите и/или асоциативността в израза определят, че първо трябва да се пресметнат стойностите на `<expr1>` и `<expr2>` и чак след това да се приложи операцията `<op>`. Казано по друг начин, `<op>` е последната операция, която би се изпълнила при пресмятането на израза.

По-долу са дадени примери за изрази в инфиксен запис и тяхното представяне като RPN:

| Инфиксен израз | Асоциативност | RPN представяне | Ред на операциите |
|----------------|---------------|-----------------|-------------------|
| `5`            |               | `5`             | 
| `3/2`          |               | `32/`           |
| `2/3+4`        |               | `23/4+`         | `(2/3)+4`
| `2+3/4`        |               | `234/+`         | `2+(3/4)`
| `2/3/4+5/6/7`  | лява          | `23/4/56/7/+`   | `((2/3)/4)+((5/6)/7)`
| `2/3/4+5/6/7`  | дясна         | `234//567//+`   | `(2/(3/4))+(5/(6/7))`
| `2+3+4/5+6+7`  | лява          | `23+45/+6+7+`   | `((((2+3)+(4/5))+6)+7)`
| `2+3+4/5+6+7`  | дясна         | `2345/67++++`   | `(2+(3+((4/5)+(6+7))))`

Обърнете внимание, че редът на аргументите винаги се запазва – дори и когато дадена операция е комутативна. Например, коректното представяне на `"2*3"` е `"23*"`, въпреки, че `"32*"` също би имал стойност 6.
