# Контролно по СДП на 2023-12-17

## Условие

Елемент на свързан списък ще представяме чрез следния клас:

```cpp
class Node {
public:
    int value;  // Стойност съхранена в елемента
    Node* next; // Указател към следващ елемент или
                // nullptr ако няма следващ елемент

    Node(int value = 0, Node* next = nullptr)
      : value(value), next(next)
    {
      // Nothing to do here
    }
};
```

Свързан списък ще представяме чрез указател към първия му елемент.
Празния списък представяме като `nullptr`.

В решението работете директно с елементите на списъка.
НЕ Е нужно да реализирате клас за работа със списък.

За всяка функция е посочена максималната допустима сложност на решението, като *N* е дължината на списъка.

Където това е необходимо, нужната памет за нови елементи от тип `Node` да се заделя с `new` и да се освобождава с `delete`.

---

### A) Освобождаване на списък

```cpp
inline void releaseList(Node* lst)
```

* Времева сложност: *O(N)*
* Пространствена сложност: *O(1)*

Получава указател към първия елемент на свързан списък. Освобождава (чрез `delete`) паметта заета от неговите елементи. Ако `lst` е `nullptr`, функцията да не прави нищо.

---

### Б) Генериране на произволен списък

```cpp
inline Node* generateRandomList(size_t length)
```

* Времева сложност: *O(N)*
* Пространствена сложност: *O(N)*

Генерира списък с дължина `length` и връща указател към първия му елемент. Стойностите на елементите на списъка да са случайно генерирани числа в интервала [0, 99]. Паметта за елементите на списъка да се заделя чрез `new`. Ако заделянето на памет не успее, от функцията трябва да излезе изключение от тип `std::bad_alloc`. В такъв случай трябва да почистите вече заделените елементи и да не допускате изтичане на памет (memory leak).

**HINT:** За да генерирате случайно число в интервала [0,99], използвайте функцията `std::rand()` от `<cstdlib>` и вземете върнатата от нея стойност по модул. Например:

```cpp
std::rand() % 100
```

---

### В) Премахване на повторения

```cpp
inline Node* removeConsecutiveDuplicates(Node* lst)
```

* Времева сложност: *O(N)*
* Пространствена сложност: *O(1)*

Премахва всички последователни повторения от списъка с начален елемент сочен от `lst`.
Премахването да работи по следния начин: всяка поредица от еднакви елементи се премахва. Освобождаването да става чрез `delete`.
Функцията не заделя памет. Връща като резултат началото на получения списък.
Ако `lst` е `nullptr`, функцията да не прави нищо.


Например, ако списъкът съдържа елементите:

```
1 → 1 → 2 → 2 → 2 → 3 → 3 → 2 → 1 → 2 → 2
```

След изпълнението на функцията, той трябва да съдържа:

```
2 → 1
```


---

### Г) Сливане

```cpp
inline Node* mergeLists(Node* lst1, Node* lst2)
```

* Времева сложност: *O(N1 + N2)*, където *N1* и *N2* са дължините съответно на `lst1` и `lst2`.
* Пространствена сложност: *O(1)*

Слива два сортирани в нарастващ ред списъка в един сортиран списък.
Функцията не трябва да заделя нови елементи.
Вместо това новият списък трябва да се получи чрез подходящо пренареждане на вече съществуващите.

Функцията връща като резултат първия елемент на новополучения списък.
Ако и `lst1`, и `lst2` са едновременно `nullptr`, функцията да връща `nullptr`.
