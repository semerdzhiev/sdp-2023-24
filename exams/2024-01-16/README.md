# Контролно по СДП на 2024-01-16

## Условие

Елемент на двоично дърво съдържащо числа ще представяме чрез следния клас:

```cpp
class TreeNode {
public:
    int data = 0;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;

    TreeNode() = default;

    TreeNode(int data)
        : data(data)
    {        
    }

    TreeNode(int data, TreeNode* left, TreeNode* right)
        : data(data), left(left), right(right)
    {
    }

    bool isLeaf() const noexcept
    {
        return left == nullptr && right == nullptr;
    }

    bool hasLeftSuccessor() const noexcept
    {
        return left != nullptr;
    }

    bool hasRightSuccessor() const noexcept
    {
        return right != nullptr;
    }
};
```

Двоично дърво ще представяме чрез указател към корена му.
Празното дърво ще представяме като `nullptr`.

В решението работете директно с елементите на дървото.
НЕ Е нужно да реализирате клас за работа с дърво.

За всяка функция е посочена максималната допустима сложност на решението. Ако *N* е коренът на двоично дърво, използваме следните означения:

* *C<sub>N</sub>* -- брой на елементите в дървото с корен *N*.
* *H<sub>N</sub>* -- височина на дървото с корен *N*.

Където това е необходимо, нужната памет за елементи от тип `Node` да се заделя с `new` и да се освобождава с `delete`.

**Общ брой точки за контролното: 10 + 2 бонус точки**

---

### А) Проверка за двоично наредено дърво (BST)

```cpp
inline bool isBst(const TreeNode* root)
```

* Времева сложност: *O(C<sub>root</sub>)*
* Пространствена сложност: *O(H<sub>root</sub>)*

Проверява дали дървото с корен `root` е BST. За определеност, считаме, че празното дърво е такова.

* Задачата носи 3,5 точки
* Просто рекурсивно решение с квадратична сложност носи 0,5 точка.
* Просто итеративно решение с квадратична сложност носи 1,5 точки.
* Пълните точки за задачата се дават за итеративно или рекурсивно решение с линейна сложност.

---

### Б) Построяване на балансирано двоично наредено дърво

```cpp
inline TreeNode* toBalancedTree(const std::vector<int>& data)
```

* Нека N = data.size().
* Времева сложност: *O(N)*
* Пространствена auxiliary сложност: *O(log N)*

Получава сортиран масив <u>**без повторения**</u> `data`. Построява балансирано <u>**по тегло**</u> двоично наредено дърво (BST) съдържащо същите числа. Ако масивът е празен да се връща празното дърво.

Ако по време на построяването на дървото възникне грешка при заделяне на памет, да се хвърли изключение от тип `std::bad_alloc`. В този случай функцията трябва да почисти заетите до момента ресурси и не трябва да се допуска изтичане на памет.

В решението можете да използвате наготово функцията `void Utils::release(TreeNode* root)`, която получава указател към корена на двоично дърво и освобождава паметта заета от неговите елементи.

* Задачата носи 1,5 точки
* Решение, което не адресира почистването на памет при възникване на грешка се оценява с максимум 0,75 точки.
* Допустимо е рекурсивно или итеративно решение.

---

### В) Изтриване на елемент

```cpp
inline TreeNode* remove(TreeNode* root, int value)
```

* Времева сложност: *O(H<sub>root</sub>)*
* Пространствена auxiliary сложност: *O(1)*

Премахва елемента `value` от дървото с корен `root`. Ако в дървото няма такъв елемент, функцията не променя нищо. Паметта за премахнатия елемент да се освободи чрез `delete`. Функцията да връща корена на полученото в резултат на изтриването дърво.

* Задачата носи 3 точки
* Допустимо е рекурсивно или итеративно решение.
* Решение, което работи с auxiliary сложност *O(H<sub>root</sub>)* се оценява с максимум 2 точки.

---

### Г) Разлика

```cpp
inline std::vector<int> removeAll(const TreeNode* from, const TreeNode* what)
```

* Времева сложност: *O(C<sub>from</sub> + C<sub>what</sub>)*
* Пространствена auxiliary сложност: *O(H<sub>from</sub> + H<sub>what</sub>)*

Връща сортиран в нарастващ ред масив от разликата на `from` и `what`. Тоест резултатът трябва да съдържа всички елементи на `from`, които НЕ СЕ срещат във `what`. Ако няма такива, функцията да връща празен масив.

* Задачата носи 4 точки
* Допустимо е рекурсивно или итеративно решение.
N