# Домашно 1: Масив и стек

## Увод

В това задание трябва да реализирате функционалността нужна за програма, която обработва изрази.

Като аргументи от командния ред програмата ще получава инфиксен израз и файл, който описва операторите използвани в израза. Тя трябва да пресметне израза и да изведе получения резултат на екрана.


## Обработка на израз

В израза могат да участват числа, операции и скоби. Скобите винаги са с най-висок приоритет. Операциите в израза са символи, които имат определен приоритет и асоциативност. Всяка операция е описана на отделен ред във входния файл. Редовете са в следния формат:

    <символ> <оператор> <приоритет> <асоциативност>

където:

* `<символ>` – символ, с който операцията се обозначава в израза. Може да бъде произволна буква от латинската азбука. За определеност считаме, че не трябва да се прави разлика между малки и големи букви. Например, `'A'` е еквивалентно на `'a'` и т.н.
* `<оператор>` – може да бъде един от `+`, `-`, `*` и  `/`. Указва какво реално прави операцията. Например, `+` е събиране, `-` е изваждане и т.н.
* `<асоциативност>` – `L` = ляво, `R` = дясно
* `<приоритет>` – Цяло число. Операция с по-голям приоритет трябва да се изпълнява преди тези с по-малък. Възможно е две операции да имат еднакви приоритети.

Пример за файл описващ операции:

    a + 10 L
    b + 5 L
    c - 5 L
    d * 10 L
    e / 10 R
    f / 10 L

Пример за израз използващ по-горните операции:

    31 a ( 5 b 32 f 10 e -230 ) c 324 d 17

За определеност считаме, че всички числа, символи и скоби участващи в израза са отделени от останалите с един или повече интервали.


## Валидиране на входа

Може да считате, че файлът с правилата за операциите ще бъде винаги валиден.

Трябва да реализирате проверка за валидност на израза. Възможни грешки са например:

* Употреба на операция, която не е описана във файла.
* Липсваща отваряща или затваряща скоба
* Няколко поредни числа без операции между тях
* и други.

Ако на функцията оценяваща стойност на израз бъде подаден некоректен израз, тя трябва да сигнализира за това като хвърли изключение (exception) от тип `incorrect_expression`. Този тип е дефиниран в предоставения за домашното шаблон. Той има конструктор с единствен аргумент – символен низ описващ грешката.

За определеност, считаме, че:

* Ако на функцията бъде подаден `nullptr` вместо израз, тя трябва да хвърли изключение от тип `incorrect_expression`.
* Празният израз (представен с празен низ или низ съставен само от интервали) има оценка 0.
* Ако изразът се състои само от едно число (например `"42"`, `" 5 "` и т.н.), то неговата оценка е това число.


## Библиотеки

Структурите от данни, които използвате в решението, или трябва да са с ваши имплементации, или да разбирате в дълбочина използваните наготово.

Допустимо е използването на следните класове от стандартната библиотека:

* [`std::array`](https://en.cppreference.com/w/cpp/container/array)
* [`std::queue`](https://en.cppreference.com/w/cpp/container/queue)
* [`std::string`](https://en.cppreference.com/w/cpp/string/basic_string)
* [`std::stack`](https://en.cppreference.com/w/cpp/container/stack)
* [`std::vector`](https://en.cppreference.com/w/cpp/container/vector)


## Допълнителни забележки

Ако в израза участват отрицателни числа, то знакът минус '-' ще бъде долепен до числото. Ако не е долепен, тогава изразът е невалиден. Например, следните изрази са валидни, ако `a` е операция описана във файла:

    52 a -53
    -10 a -20

Докато следните НЕ СА валидни:

    52 a - 53
    52 - 53

Най-вероятно, за да решите задачата ще е нужно да добавите помощни функции и/или класове. Препоръчваме ви да ги покриете с подходящи unit test-ове.


## Шаблон

В шаблона за домашното са включени отделни target-и за програмата и за библиотека, която реализира същинската обработка на изрази.

Кодът на програмата е завършен и НЕ трябва да го променяте. Той се намира в директорията [`src/application/`](template/src/application/). В нея не бива да нанасяте промени.

Кодът на библиотеката, която реализира обработка на изрази се намира в [`src/expression-lib/`](template/src/expression-lib/). Това е директорията, в която трябва основно да работите. Можете да реализирате цялото си решение в предоставените файлове, но може и да добавите допълнителни, ако има нужда.

Тестовете се намират в [`test/`](template/test/). НЕ бива променяте предоставения файл с тестове. Ако искате да добавите свои unit test-ове, създайте допълнителни файлове.

Директорията [`sample-inputs/`](template/sample-inputs/) съдържа примерни входни данни, които може да се подадат на програмата.

Файлът `CMakeLists.txt` в основната директория също НЕ бива да се променя.

По подразбиране CMake проектът е настроен така, че да сваля автоматично Catch2 използвайки FetchContent. За по-ефективно, препоръчваме да свалите рамката и да работите с локална версия. Това може да стане по два начина:

* Като свалите цялото съдържание на repo-то на Catch2 и го сложите в поддиректория `lib/Catch2` на проекта.
* Като свалите, предварително изградите и инсталирате Catch2 на вашия компютър така, че да може се намира с `find_package()`.

## Упътвания

Спазвайте принципа за [Single responsibility](https://en.wikipedia.org/wiki/Single-responsibility_principle). Работете с малки единици (класове/функции).

Ако отделите достатъчно време, за да можете да работите спокойно по заданието, опитайте да следвате колкото се може по-близо [TDD](https://en.wikipedia.org/wiki/Test-driven_development). Най-вероятно това ще подобри значително качеството на кода ви, а също и ще ви позволи отрано да хванете проблеми в архитектурата на решението. Ако срещате проблеми с тестването на дадена част от кода или въобще не виждате начин да я тествате, вероятно има някакъв проблем с дизайна.

Не усложнявайте излишно решението. Помислете какво наистина ви е нужно. В частност:

* Забележете, че цялата информация от входния файл може да се прочете с базовите операции, които потоците предлагат. Не усложнявайте излишно входа.

Задачата е упражнение върху масив, стек и опашка. Помислете кои от тях ще са ви нужни и как да ги използвате ефективно. В тази връзка:

* Възможните операции, които могат да участват в един израз са краен брой. Колко е горната граница? Малка ли е или голяма? Колко е максималното количество памет, което би било нужно, за да представите един набор от операции?
* Има ли начин да съхраните прочетените от вас операции по такъв начин, че за време O(1) да може да проверите дали дадена операция е дефинирана и какви са нейните свойства?

Спазвайте принципа за [Dependency inversion](https://en.wikipedia.org/wiki/Dependency_inversion_principle). Разчитайте на абстракции, а не на конкретна имплементация. Мислете за интерфейсите между отделните части, стремете се да намалите зависимостите от конкретна имплементация. В частност:

* Вероятно ще бъде по-добре да въведете клас, който представя колекция от операции (да речем `OperationSet`), вместо да работите директно с масив от операции. Например, той може да има методи `add`, `get`, `contains` и т.н., с които да може да се добавя операция, да се провери дали дадена операция е дефинирана за израза и т.н. Респективно и да прави нужните проверки за коректност и да хвърля изключение тогава, когато е нужно. Не натоварвайте класа с излишни операции. Например, ако в колекцията само се добавя, но никога не се премахва операция, няма нужда да добавяте функция `remove`.
