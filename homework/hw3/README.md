# Домашно 3: Двоични наредени дървета (BST)

## Редакции

### 2024-01-09

* В оригиналния документ сложностите бяха описани с допускането, че става дума за балансирани дървета (т.е. че операциите се извършват върху дърветата, които се получават непосредствено сред десериализация). За да се избегнат възможни недоразумения, описанието е коригирано така, че някои от сложностите са изразени спрямо височината на дървото.

## Увод

Множество от цели числа без повторение на елементите ще представяме чрез описания по-долу клас.

```cpp
class IntegerSet {
private:
  // Добавете подходящи член-данни

public:
  IntegerSet();
  IntegerSet(const IntegerSet&);
  IntegerSet& operator=(const IntegerSet&);
  ~IntegerSet();

public:
  // Връща броя на елементите в множеството
  size_t size() const;

  /// Проверява дали елемент се съдържа в множество
  bool countains(int) const;

  /// Проверява дали две множества се състоят от едни и същи елементи
  bool equals(const IntegerSet&) const;

  /// Проверява дали текущият обект е подмножество на друг
  bool subsetOf(const IntegerSet&) const;

  /// Връща обединението на две множества
  IntegerSet getUnion(const IntegerSet&) const;
  
  /// Връща сечението на две множества
  IntegerSet getIntersection(const IntegerSet&) const;

  /// Десериализира съдържанието на едно множество.
  /// Новата информация напълно заменя старата.
  void deserialize(std::istream&);

  /// Сериализира съдържанието на едно множество
  void serialize(std::ostream&) const;
};

inline std::istream& operator>>(std::istream& in, IntegerSet& set)
{
  set.deserialize(in);
  return in;
}

inline std::ostream& operator<<(std::ostream& out, const IntegerSet& set)
{
  set.serialize(out);
  return out;
}
```

Реализирайте всички операции на класа.

Позволено е (и желателно) да добавите допълнителни помощни функции в класа `IntegerSet`.

Вътрешно множеството трябва да се представи като двоично наредено дърво. Представянето на дървото да бъде чрез обекти от вида:

```cpp
class Node {
public:
  int value;
  Node* left;
  Node* right;
};
```

Можете да добавите допълнителни членове към класа `Node`.

Ако в някоя от операциите възникне проблем при заделяне на паметта, да се хвърля изключение от тип `std::bad_alloc`.

За всяка от операциите се уверете, че не се допуска изтичане на памет. Например, ако дървото е построено донякъде и след това се получи грешка при заделяне на памет, трябва да почистите заделените до момента ресурси.

## Сериализация/десериализация

Съдържанието на едно множество представяме чрез символен низ като последователност от числа -- най-напред число N указващо броя на елементите, следвано от точно N числа Наредени в строго нарастващ ред. Например, множеството {10, 20, 30} представяме като:

```text
3 10 20 30
```

Операциите по сериализация и десериализация трябва да извеждат/въвеждат само информацията нужна за множеството и да не добавят/извличат друга информация от съответния поток. Например:

```cpp
// съдържа представянето на две множества и две думи
std::stringstream str("3 10 20 30 hello 2 100 200 world");
IntegerSet s1, s2;
std::string w1, w2;

// Въвежда от потока две множества и две думи
str >> s1 >> w1 >> s2 >> w2;

// Извежда "This is a set: -- 3 10 20 30 --"
std::cout << "This is a set: -- " << s1 << " --";
```

При десериализацията проверявайте за коректността на входа. Ако възникне проблем, да се хвърли изключение от тип `std::runtime_error`.

## Сложност

По-долу в текста сме обозначили:

* *C<sub>n</sub>* -- броя на елементите в текущия обект
* *C<sub>m</sub>* -- броя на елементите в обекта, който се подава като аргумент на `equals`, `subsetOf` и т.н.
* *H<sub>n</sub>* -- височината на дървото в текущия обект
* *H<sub>m</sub>* -- височината на дървото в обекта, който се подава като аргумент на `equals`, `subsetOf` и т.н.

Използваната памет за обект от тип `IntegerSet` трябва да бъде от порядъка на *O(C<sub>n</sub>)*.

Сложността на всички операции с две множества (еквивалентност, подмножество, обединение, сечение) трябва да бъде:

* Времева: *O(C<sub>n</sub>+C<sub>m</sub>)*
* Auxiliary: *O(H<sub>n</sub>+H<sub>m</sub>)*

Напомняме, че auxiliary сложността се отнася до паметта, която алгоритъмът използва, без да броим размера на входа. Например, ако даден алгоритъм получава вход с варираща дължина *N*, но има нужда само от две променливи от тип `int`, за да го обходи, тогава auxiliary сложността е *O(1)*.

Допустимо е при намирането на обединение и сечение да се получи изродено двоично дърво.

За сериализацията сложността да бъде:

* Времева: *O(C<sub>n</sub>)*
* Auxiliary: *O(H<sub>n</sub>)*

Десериализацията трябва да построява *балансирано по тегло* двоично наредено дърво. Сложността да бъде:

* Времева: *O(C<sub>n</sub>)*
* Auxiliary: *O(C<sub>n</sub>)*

## Допълнителни библиотеки

В решението си можете да използвате следните контейнери от STL:

* `std::vector`
* `std::stack`
* `std::queue`

## Шаблон

Предоставен е шаблон, в който да работите върху задачата. Той се намира в директорията `template/`.

Шаблонът съдържа unit test-ове, които проверяват решението за коректност. Възможно е те да не покриват всички възможни случаи. Допълнете ги ако се досетите за други неща, които трябва да се проверят.

**ВАЖНО:** НЕ променяйте предоставения файл с unit test-ове, нито основния `CMakeLists.txt` файл. Вместо това, добавете един или повече нови файлове в папката `test/` и напишете в тях своите тестове.

Когато решавате домашното НЕ може да променяте следните:

* Помощните функции (ако такива са били предоставени в шаблона).
* Прототипите на функциите, които трябва да се реализират. Например, не може да променяте имената им, типовете на параметрите на функциите, типовете на връщаните стойности и т.н.
* Предоставените unit test-ове.
* `CMakeLists.txt` файла в основната директория на проекта.

## Предаване на решението

Предайте решението си като един `.zip` архив. Включете в него само това, което е нужно, за да се изгради и тества решението.

**ВАЖНО:** Напомняме, че част от файловете в шаблона не бива да се променят. Уверете се, че предавате оригиналните версии заедно с работата си.

Освен ако НЕ СТЕ добавяли допълнителни директории, архивирайте и предайте само следните файлове/директории:

* `src/`
* `test/`
* `CMakeLists.txt`

Запазете структурата на шаблона. НЕ размествайте файловете, НЕ променяйте техните имена и т.н.

НЕ СЛАГАЙТЕ в архива временните файлове и директории генерирани от IDE-то, компилатора и т.н. (например `.vscode/`, `build/`, `out/` и т.н.).

**СЪВЕТ:** Би трябвало архивът да е с размер по-малък от 1MB, даже много по-малко (за тази задача вероятно ще е от порядъка на килобайти). Ако предавате архив с голям обем (например 30MB), със сигурност в него сте включили излишни неща.

След като предадете решението, за да се уверите, че всичко е оформено коректно, свалете архива от Moodle и проверете дали изграждането и тестовете преминават без грешки. За целта:

1. Свалете архива от Moodle.
1. Разархивирайте го в отделна, нова директория, например `C:\Temp\sdp-homework`.
1. Изградете решението си и пуснете тестовете. Всички стъпки трябва да преминават без грешки. Например, за директорията по-горе стъпките биха изглеждали така:

```bash
cd "C:\Temp\sdp-homework"
cmake -S . -B ./build
cmake --build ./build
ctest --test-dir ./build
```
